export const title = 'Getting Started'
export const description = 'Learn how to create your first Rari application with React Server Components and Rust-powered performance.'

# Getting Started with Rari

This guide will walk you through creating your first Rari application from scratch. You'll learn the basics of React Server Components with Rari's high-performance Rust runtime.

## Prerequisites

Before you begin, ensure you have the following installed:

- **Node.js 20+**
- **A modern package manager (e.g. npm, pnpm, bun or deno)**
- **A modern code editor**

## Installation

### Option 1: Create New Project (Recommended)

The fastest way to get started is with our project generator:

```bash
pnpm create rari-app@latest my-rari-app
cd my-rari-app
pnpm dev
```

Or with other package managers:

```bash
# Using npm
npm create rari-app my-rari-app

# Using bun
bun create rari-app my-rari-app
```

### Option 2: Add to Existing Vite Project

If you have an existing Vite + React project:

```bash
pnpm add rari
```

Update your `vite.config.ts`:

```typescript
import { rari, rariRouter } from 'rari/vite'
import { defineConfig } from 'vite'

export default defineConfig({
  plugins: [
    rari(),
    rariRouter(),
  ],
})
```

## Your First App Router Page

With the app router, your application structure is based on the `src/app/` directory. Let's create your first page.

Create `src/app/layout.tsx` (root layout):

```tsx
import type { LayoutProps } from 'rari/client'

export default function RootLayout({ children }: LayoutProps) {
  return (
    <div>
      <nav>
        <a href="/">Home</a>
        <a href="/about">About</a>
      </nav>
      <main>{children}</main>
    </div>
  )
}

export const metadata = {
  title: 'My Rari App',
  description: 'Built with Rari',
}
```

Create `src/app/page.tsx` (home page):

```tsx
import type { PageProps } from 'rari/client'
import Counter from '@/components/Counter'

// This is a React Server Component - runs on the server!
export default async function HomePage({ params, searchParams }: PageProps) {
  // Fetch data on the server
  const response = await fetch('https://api.github.com/repos/facebook/react')
  const repoData = await response.json()

  return (
    <div>
      <h1>Welcome to Rari</h1>

      {/* Server-rendered content */}
      <div>
        <h2>React Repository Stats</h2>
        <p>Stars: {repoData.stargazers_count.toLocaleString()}</p>
        <p>Forks: {repoData.forks_count.toLocaleString()}</p>
        <p>Watchers: {repoData.watchers_count.toLocaleString()}</p>
        <p>Last updated: {new Date(repoData.updated_at).toLocaleDateString()}</p>
      </div>

      {/* Client Component */}
      <Counter />
    </div>
  )
}

export const metadata = {
  title: 'Home | My Rari App',
  description: 'Welcome to my Rari application',
}
```

Create `src/components/Counter.tsx` (client component):

```tsx
'use client'

import { useState } from 'react'

export default function Counter() {
  const [count, setCount] = useState(0)

  return (
    <div>
      <h2>Client Interaction</h2>
      <button onClick={() => setCount(count + 1)} type="button">
        Count: {count}
      </button>
    </div>
  )
}
```

## Using NPM Packages

One of Rari's superpowers is seamless NPM package integration. Let's add markdown support:

```bash
pnpm add marked
```

Create `src/components/MarkdownPost.tsx`:

```tsx
import { marked } from 'marked'

interface MarkdownPostProps {
  content: string
  title: string
}

export default async function MarkdownPost({ content, title }: MarkdownPostProps) {
  // Process markdown on the server
  marked.setOptions({
    gfm: true,
    breaks: false,
  })
  const htmlContent = await marked.parse(content)

  return (
    <article>
      <h1>{title}</h1>
      <div dangerouslySetInnerHTML={{ __html: htmlContent }} />
    </article>
  )
}
```

Use it in a page:

```tsx
// src/app/blog/page.tsx
import MarkdownPost from '@/components/MarkdownPost'

const blogPost = `
# Welcome to Rari!

This markdown is processed **on the server** using the \`marked\` package.

- Fast server-side rendering
- Universal NPM package support
- Zero configuration required
`

export default function BlogPage() {
  return (
    <div>
      <MarkdownPost title="My Blog Post" content={blogPost} />
    </div>
  )
}

export const metadata = {
  title: 'Blog | My Rari App',
  description: 'Read our latest posts',
}
```

## Development Workflow

### Start Development Server

```bash
pnpm dev
```

Your app will be available at `http://localhost:5173` (Vite default) with:
- **Hot module reloading** for instant updates
- **Error overlay** for debugging
- **Fast Rust runtime** powering server components
- **TypeScript support** out of the box

### Build for Production

```bash
pnpm build
```

This creates an optimized production build with:
- **Automatic code splitting**
- **Asset optimization**
- **Server bundle generation**

### Start Production Server

```bash
pnpm start
```

Runs your optimized app in production mode.

## Project Structure

A typical Rari project (created with `create-rari-app`) looks like this:

```
my-rari-app/
├── src/
│   ├── app/
│   │   ├── layout.tsx
│   │   ├── page.tsx
│   │   ├── globals.css
│   │   ├── about/
│   │   │   └── page.tsx
│   │   ├── blog/
│   │   │   ├── page.tsx
│   │   │   └── [slug]/
│   │   │       └── page.tsx
│   │   └── users/
│   │       └── [id]/
│   │           └── page.tsx
│   ├── components/
│   │   └── Counter.tsx
│   ├── actions/
│   │   └── todo-actions.ts
│   └── vite-env.d.ts
├── public/
├── index.html
├── package.json
├── vite.config.ts
├── tsconfig.json
├── tsconfig.app.json
├── tsconfig.node.json
└── .gitignore
```

## App Router

Rari uses the app router pattern where your file structure in `src/app/` automatically determines your application routes. This makes organizing your application intuitive and scalable.

### Basic Routes

Routes are created by adding `page.tsx` files in the `src/app/` directory:

- `src/app/page.tsx` → `/`
- `src/app/about/page.tsx` → `/about`
- `src/app/contact/page.tsx` → `/contact`

```tsx
// src/app/about/page.tsx
import type { PageProps } from 'rari/client'

export default function AboutPage({ params, searchParams }: PageProps) {
  return (
    <div>
      <h1>About Us</h1>
      <p>Welcome to our amazing application!</p>
    </div>
  )
}

export const metadata = {
  title: 'About | My App',
  description: 'Learn more about us',
}
```

### Dynamic Routes

Use square brackets for dynamic route parameters:

- `src/app/users/[id]/page.tsx` → `/users/123`
- `src/app/blog/[slug]/page.tsx` → `/blog/my-post`

```tsx
// src/app/users/[id]/page.tsx
import type { PageProps } from 'rari/client'

export default function UserPage({ params }: PageProps<{ id: string }>) {
  const { id } = params

  return (
    <div>
      <h1>User Profile</h1>
      <p>User ID: {id}</p>
    </div>
  )
}

export async function generateMetadata({ params }: PageProps<{ id: string }>) {
  return {
    title: `User ${params.id} | My App`,
    description: `Profile page for user ${params.id}`,
  }
}
```

### Layouts

Layouts wrap pages and can be nested. They persist across route changes:

```tsx
// src/app/layout.tsx - Root layout (required)
import type { LayoutProps } from 'rari/client'

export default function RootLayout({ children }: LayoutProps) {
  return (
    <div>
      <nav>
        <a href="/">Home</a>
        <a href="/about">About</a>
      </nav>
      <main>{children}</main>
    </div>
  )
}

export const metadata = {
  title: 'My App',
  description: 'Built with Rari',
}
```

```tsx
// src/app/dashboard/layout.tsx - Nested layout
import type { LayoutProps } from 'rari/client'

export default function DashboardLayout({ children }: LayoutProps) {
  return (
    <div>
      <aside>
        <nav>
          <a href="/dashboard">Overview</a>
          <a href="/dashboard/analytics">Analytics</a>
          <a href="/dashboard/settings">Settings</a>
        </nav>
      </aside>
      <div>{children}</div>
    </div>
  )
}
```

### Navigation

Use standard HTML links for navigation - the app router handles client-side navigation automatically:

```tsx
export default function Navigation() {
  return (
    <nav>
      <a href="/">Home</a>
      <a href="/about">About</a>
      <a href="/blog">Blog</a>
    </nav>
  )
}
```

## Server vs Client Components

### Server Components (Default)
- Run on the server during rendering
- Can use async/await and server-only APIs
- Cannot use browser APIs or event handlers
- Automatically serialized for the client

```tsx
export default async function ServerComponent() {
  const data = await fetch('https://api.example.com/data')
  const result = await data.json()
  return <div>{result.message}</div>
}
```

### Client Components
- Run in the browser
- Can use hooks, event handlers, browser APIs
- Cannot use server-only APIs
- Use `'use client'` directive to mark explicitly

```tsx
'use client'

import { useState } from 'react'

export default function ClientComponent() {
  const [count, setCount] = useState(0)

  return (
    <button onClick={() => setCount(count + 1)} type="button">
      Clicked {count} times
    </button>
  )
}
```

### Server Actions
- Use `'use server'` directive for server functions that can be called from client components
- Place in `src/actions/` directory for organization

```tsx
// src/actions/user-actions.ts
'use server'

export async function createUser(formData: FormData) {
  const name = formData.get('name') as string
  const email = formData.get('email') as string

  const user = await database.users.create({ name, email })
  return { success: true, user }
}

export async function deleteUser(id: string) {
  await database.users.delete(id)
  return { success: true }
}
```

Use server actions in client components with `useActionState`:

```tsx
// src/components/UserForm.tsx
'use client'

import { useActionState } from 'react'
import { createUser } from '@/actions/user-actions'

export default function UserForm() {
  const [state, formAction, isPending] = useActionState(createUser, null)

  return (
    <form action={formAction}>
      <input name="name" required />
      <input name="email" type="email" required />
      <button type="submit" disabled={isPending}>
        {isPending ? 'Creating...' : 'Create User'}
      </button>
      {state?.success && <p>User created successfully!</p>}
    </form>
  )
}
```

## Common Patterns

### Loading Data in Pages

```tsx
// src/app/users/[id]/page.tsx
import type { PageProps } from 'rari/client'

export default async function UserProfile({ params }: PageProps<{ id: string }>) {
  const { id } = params

  // Fetch data on the server
  const user = await fetch(`https://api.example.com/users/${id}`)
    .then(r => r.json())

  return (
    <div>
      <h1>{user.name}</h1>
      <p>{user.email}</p>
      <p>Joined: {user.createdAt}</p>
    </div>
  )
}

export async function generateMetadata({ params }: PageProps<{ id: string }>) {
  const user = await fetch(`https://api.example.com/users/${params.id}`)
    .then(r => r.json())

  return {
    title: `${user.name} | Users`,
    description: `Profile page for ${user.name}`,
  }
}
```

### Combining Server and Client

```tsx
// src/app/dashboard/page.tsx - Server component that includes client components
import type { PageProps } from 'rari/client'
import ClientCounter from '@/components/ClientCounter'

export default async function Dashboard({ params, searchParams }: PageProps) {
  const stats = await getServerStats()

  return (
    <div>
      <h1>Dashboard</h1>
      <div>Server stats: {stats.totalUsers}</div>
      <ClientCounter />
    </div>
  )
}

export const metadata = {
  title: 'Dashboard | My App',
  description: 'Your dashboard',
}
```

### Error Handling

```tsx
export default async function DataComponent() {
  let data
  let error

  try {
    data = await fetchSomeData()
  }
  catch (err) {
    error = err
  }

  if (error) {
    return (
      <div>
        <h2>Something went wrong</h2>
        <p>{error instanceof Error ? error.message : 'Unknown error'}</p>
      </div>
    )
  }

  return <div>{data.content}</div>
}
```
