export const title = 'Getting Started'
export const description = 'Learn how to create your first Rari application with React Server Components and Rust-powered performance.'

# Getting Started with Rari

This guide will walk you through creating your first Rari application from scratch. You'll learn the basics of React Server Components with Rari's high-performance Rust runtime.

## Prerequisites

Before you begin, ensure you have the following installed:

- **Node.js `20.x`** (<a href="https://nodejs.org/" target="_blank" rel="noopener noreferrer">Active LTS</a> release recommended)
- **A modern package manager** (we recommended <a href="https://pnpm.io/" target="_blank" rel="noopener noreferrer">pnpm</a>)
- **A modern code editor**

## Installation

### Option 1: Create New Project (Recommended)

The fastest way to get started is with our project generator:

<PackageManagerTabs
  commands={{
    pnpm: 'pnpm create rari-app@latest my-rari-app',
    npm: 'npm create rari-app@latest my-rari-app',
    yarn: 'yarn create rari-app my-rari-app',
    bun: 'bun create rari-app my-rari-app',
    deno: 'deno run -A npm:create-rari-app@latest my-rari-app'
  }}
/>

Navigate to your project directory:

<TerminalBlock command="cd my-rari-app" />

Start the development server:

<PackageManagerTabs
  commands={{
    pnpm: 'pnpm dev',
    npm: 'npm run dev',
    yarn: 'yarn dev',
    bun: 'bun dev',
    deno: 'deno task dev'
  }}
/>

### Option 2: Add to Existing Vite Project

If you have an existing Vite + React project:

<PackageManagerTabs
  commands={{
    pnpm: 'pnpm add rari',
    npm: 'npm install rari',
    yarn: 'yarn add rari',
    bun: 'bun add rari',
    deno: 'deno add npm:rari'
  }}
/>

Update your `vite.config.ts`:

<CodeBlock filename="vite.config.ts" language="typescript">{`import { rari } from 'rari/vite'
import { defineConfig } from 'vite'

export default defineConfig({
  plugins: [
    rari(),
  ],
})
`}</CodeBlock>

## Your First App Router Page

With the app router, your application structure is based on the `src/app/` directory. Let's create your first page.

Create `src/app/layout.tsx` (root layout):

<CodeBlock filename="src/app/layout.tsx" language="tsx">{`import type { LayoutProps } from 'rari/client'

export default function RootLayout({ children }: LayoutProps) {
  return (
    <div>
      <nav>
        <a href="/">Home</a>
        <a href="/about">About</a>
      </nav>
      <main>{children}</main>
    </div>
  )
}

export const metadata = {
  title: 'My Rari App',
  description: 'Built with Rari',
}
`}</CodeBlock>

Create `src/app/page.tsx` (home page):

<CodeBlock filename="src/app/page.tsx" language="tsx">{`import type { PageProps } from 'rari/client'
import Counter from '@/components/Counter'

// This is a React Server Component - runs on the server!
export default async function HomePage({ params, searchParams }: PageProps) {
  // Fetch data on the server
  const response = await fetch('https://api.github.com/repos/facebook/react')
  const repoData = await response.json()

  return (
    <div>
      <h1>Welcome to Rari</h1>

      {/* Server-rendered content */}
      <div>
        <h2>React Repository Stats</h2>
        <p>Stars: {repoData.stargazers_count.toLocaleString()}</p>
        <p>Forks: {repoData.forks_count.toLocaleString()}</p>
        <p>Watchers: {repoData.watchers_count.toLocaleString()}</p>
        <p>Last updated: {new Date(repoData.updated_at).toLocaleDateString()}</p>
      </div>

      {/* Client Component */}
      <Counter />
    </div>
  )
}

export const metadata = {
  title: 'Home | My Rari App',
  description: 'Welcome to my Rari application',
}
`}</CodeBlock>

Create `src/components/Counter.tsx` (client component):

<CodeBlock filename="src/components/Counter.tsx" language="tsx">{`'use client'

import { useState } from 'react'

export default function Counter() {
  const [count, setCount] = useState(0)

  return (
    <div>
      <h2>Client Interaction</h2>
      <button onClick={() => setCount(count + 1)} type="button">
        Count: {count}
      </button>
    </div>
  )
}
`}</CodeBlock>

## Using NPM Packages

One of Rari's superpowers is seamless NPM package integration. Let's add markdown support:

<PackageManagerTabs
  commands={{
    pnpm: 'pnpm add marked',
    npm: 'npm install marked',
    yarn: 'yarn add marked',
    bun: 'bun add marked',
    deno: 'deno add npm:marked'
  }}
/>

Create `src/components/MarkdownPost.tsx`:

<CodeBlock filename="src/components/MarkdownPost.tsx" language="tsx">{`import { marked } from 'marked'

interface MarkdownPostProps {
  content: string
  title: string
}

export default async function MarkdownPost({ content, title }: MarkdownPostProps) {
  // Process markdown on the server
  marked.setOptions({
    gfm: true,
    breaks: false,
  })
  const htmlContent = await marked.parse(content)

  return (
    <article>
      <h1>{title}</h1>
      <div dangerouslySetInnerHTML={{ __html: htmlContent }} />
    </article>
  )
}
`}</CodeBlock>

Use it in a page:

<CodeBlock filename="src/app/blog/page.tsx" language="tsx">{`import MarkdownPost from '@/components/MarkdownPost'

const blogPost = \`
# Welcome to Rari!

This markdown is processed **on the server** using the \\\`marked\\\` package.

- Fast server-side rendering
- Universal NPM package support
- Zero configuration required
\`

export default function BlogPage() {
  return (
    <div>
      <MarkdownPost title="My Blog Post" content={blogPost} />
    </div>
  )
}

export const metadata = {
  title: 'Blog | My Rari App',
  description: 'Read our latest posts',
}
`}</CodeBlock>

## Development Workflow

### Start Development Server

<PackageManagerTabs
  commands={{
    pnpm: 'pnpm dev',
    npm: 'npm run dev',
    yarn: 'yarn dev',
    bun: 'bun dev',
    deno: 'deno task dev'
  }}
/>

Your app will be available at `http://localhost:5173` (Vite default) with:
- **Hot module reloading** for instant updates
- **Error overlay** for debugging
- **Fast Rust runtime** powering server components
- **TypeScript support** out of the box

### Build for Production

<PackageManagerTabs
  commands={{
    pnpm: 'pnpm build',
    npm: 'npm run build',
    yarn: 'yarn build',
    bun: 'bun build',
    deno: 'deno task build'
  }}
/>

This creates an optimized production build with:
- **Automatic code splitting**
- **Asset optimization**
- **Server bundle generation**

### Start Production Server

<PackageManagerTabs
  commands={{
    pnpm: 'pnpm start',
    npm: 'npm start',
    yarn: 'yarn start',
    bun: 'bun start',
    deno: 'deno task start'
  }}
/>

Runs your optimized app in production mode.

## Project Structure

A typical Rari project (created with `create-rari-app`) looks like this:

<CodeBlock language="bash">{`my-rari-app/
├── src/
│   ├── app/
│   │   ├── layout.tsx
│   │   ├── page.tsx
│   │   ├── globals.css
│   │   ├── about/
│   │   │   └── page.tsx
│   │   ├── blog/
│   │   │   ├── page.tsx
│   │   │   └── [slug]/
│   │   │       └── page.tsx
│   │   └── users/
│   │       └── [id]/
│   │           └── page.tsx
│   ├── components/
│   │   └── Counter.tsx
│   └── actions/
│       └── todo-actions.ts
├── public/
├── index.html
├── package.json
├── vite.config.ts
├── tsconfig.json
└── .gitignore
`}</CodeBlock>

## App Router

Rari uses the app router pattern where your file structure in `src/app/` automatically determines your application routes. This makes organizing your application intuitive and scalable.

### Basic Routes

Routes are created by adding `page.tsx` files in the `src/app/` directory:

- `src/app/page.tsx` → `/`
- `src/app/about/page.tsx` → `/about`
- `src/app/contact/page.tsx` → `/contact`

<CodeBlock filename="src/app/about/page.tsx" language="tsx">{`import type { PageProps } from 'rari/client'

export default function AboutPage({ params, searchParams }: PageProps) {
  return (
    <div>
      <h1>About Us</h1>
      <p>Welcome to our amazing application!</p>
    </div>
  )
}

export const metadata = {
  title: 'About | My App',
  description: 'Learn more about us',
}
`}</CodeBlock>

### Dynamic Routes

Use square brackets for dynamic route parameters:

- `src/app/users/[id]/page.tsx` → `/users/123`
- `src/app/blog/[slug]/page.tsx` → `/blog/my-post`

<CodeBlock filename="src/app/users/[id]/page.tsx" language="tsx">{`import type { PageProps } from 'rari/client'

export default function UserPage({ params }: PageProps<{ id: string }>) {
  const { id } = params

  return (
    <div>
      <h1>User Profile</h1>
      <p>User ID: {id}</p>
    </div>
  )
}

export async function generateMetadata({ params }: PageProps<{ id: string }>) {
  return {
    title: \`User \${params.id} | My App\`,
    description: \`Profile page for user \${params.id}\`,
  }
}
`}</CodeBlock>

### Layouts

Layouts wrap pages and can be nested. They persist across route changes:

<CodeBlock filename="src/app/layout.tsx" language="tsx">{`import type { LayoutProps } from 'rari/client'

export default function RootLayout({ children }: LayoutProps) {
  return (
    <div>
      <nav>
        <a href="/">Home</a>
        <a href="/about">About</a>
      </nav>
      <main>{children}</main>
    </div>
  )
}

export const metadata = {
  title: 'My App',
  description: 'Built with Rari',
}
`}</CodeBlock>

<CodeBlock filename="src/app/dashboard/layout.tsx" language="tsx">{`import type { LayoutProps } from 'rari/client'

export default function DashboardLayout({ children }: LayoutProps) {
  return (
    <div>
      <aside>
        <nav>
          <a href="/dashboard">Overview</a>
          <a href="/dashboard/analytics">Analytics</a>
          <a href="/dashboard/settings">Settings</a>
        </nav>
      </aside>
      <div>{children}</div>
    </div>
  )
}
`}</CodeBlock>

### Navigation

Use standard HTML links for navigation - the app router handles client-side navigation automatically:

<CodeBlock language="tsx">{`export default function Navigation() {
  return (
    <nav>
      <a href="/">Home</a>
      <a href="/about">About</a>
      <a href="/blog">Blog</a>
    </nav>
  )
}
`}</CodeBlock>

## Server vs Client Components

### Server Components (Default)
- Run on the server during rendering
- Can use async/await and server-only APIs
- Cannot use browser APIs or event handlers
- Automatically serialized for the client

<CodeBlock language="tsx">{`export default async function ServerComponent() {
  const data = await fetch('https://api.example.com/data')
  const result = await data.json()
  return <div>{result.message}</div>
}
`}</CodeBlock>

### Client Components
- Run in the browser
- Can use hooks, event handlers, browser APIs
- Cannot use server-only APIs
- Use `'use client'` directive to mark explicitly

<CodeBlock language="tsx">{`'use client'

import { useState } from 'react'

export default function ClientComponent() {
  const [count, setCount] = useState(0)

  return (
    <button onClick={() => setCount(count + 1)} type="button">
      Clicked {count} times
    </button>
  )
}
`}</CodeBlock>

### Server Actions
- Use `'use server'` directive for server functions that can be called from client components
- Place in `src/actions/` directory for organization

<CodeBlock filename="src/actions/user-actions.ts" language="tsx">{`'use server'

export async function createUser(formData: FormData) {
  const name = formData.get('name') as string
  const email = formData.get('email') as string

  const user = await database.users.create({ name, email })
  return { success: true, user }
}

export async function deleteUser(id: string) {
  await database.users.delete(id)
  return { success: true }
}
`}</CodeBlock>

Use server actions in client components with `useActionState`:

<CodeBlock filename="src/components/UserForm.tsx" language="tsx">{`'use client'

import { useActionState } from 'react'
import { createUser } from '@/actions/user-actions'

export default function UserForm() {
  const [state, formAction, isPending] = useActionState(createUser, null)

  return (
    <form action={formAction}>
      <input name="name" required />
      <input name="email" type="email" required />
      <button type="submit" disabled={isPending}>
        {isPending ? 'Creating...' : 'Create User'}
      </button>
      {state?.success && <p>User created successfully!</p>}
    </form>
  )
}
`}</CodeBlock>

## Common Patterns

### Loading Data in Pages

<CodeBlock filename="src/app/users/[id]/page.tsx" language="tsx">{`import type { PageProps } from 'rari/client'

export default async function UserProfile({ params }: PageProps<{ id: string }>) {
  const { id } = params

  // Fetch data on the server
  const user = await fetch(\`https://api.example.com/users/\${id}\`)
    .then(r => r.json())

  return (
    <div>
      <h1>{user.name}</h1>
      <p>{user.email}</p>
      <p>Joined: {user.createdAt}</p>
    </div>
  )
}

export async function generateMetadata({ params }: PageProps<{ id: string }>) {
  const user = await fetch(\`https://api.example.com/users/\${params.id}\`)
    .then(r => r.json())

  return {
    title: \`\${user.name} | Users\`,
    description: \`Profile page for \${user.name}\`,
  }
}
`}</CodeBlock>

### Combining Server and Client

<CodeBlock filename="src/app/dashboard/page.tsx" language="tsx">{`import type { PageProps } from 'rari/client'
import ClientCounter from '@/components/ClientCounter'

export default async function Dashboard({ params, searchParams }: PageProps) {
  const stats = await getServerStats()

  return (
    <div>
      <h1>Dashboard</h1>
      <div>Server stats: {stats.totalUsers}</div>
      <ClientCounter />
    </div>
  )
}

export const metadata = {
  title: 'Dashboard | My App',
  description: 'Your dashboard',
}
`}</CodeBlock>

### Error Handling

<CodeBlock language="tsx">{`export default async function DataComponent() {
  let data
  let error

  try {
    data = await fetchSomeData()
  }
  catch (err) {
    error = err
  }

  if (error) {
    return (
      <div>
        <h2>Something went wrong</h2>
        <p>{error instanceof Error ? error.message : 'Unknown error'}</p>
      </div>
    )
  }

  return <div>{data.content}</div>
}
`}</CodeBlock>
